<html>
<head>
<link rel="stylesheet" href="css/posts.css" />
</head>
<body>
<h1><a href="index.html">&lt;- fans656's blog</a></h1>
<p>
<span class="date">2016-10-27&nbsp;16:22:59</span><br>
[leetcode<br>
&nbsp;&nbsp;&nbsp;&nbsp;17<br>
&nbsp;&nbsp;&nbsp;&nbsp;letter&nbsp;combinations&nbsp;of&nbsp;a&nbsp;phone&nbsp;number<br>
]<br>
Method&nbsp;1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;自己的做法<br>
&nbsp;&nbsp;&nbsp;&nbsp;所求结果就是每个digit代表的字符set的笛卡尔积<br>
&nbsp;&nbsp;&nbsp;&nbsp;用iters存储指向每个set中字符的index<br>
&nbsp;&nbsp;&nbsp;&nbsp;然后递增iters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;0&nbsp;0&nbsp;-&gt;&nbsp;0&nbsp;0&nbsp;1&nbsp;-&gt;&nbsp;0&nbsp;0&nbsp;2&nbsp;-&gt;&nbsp;0&nbsp;1&nbsp;0&nbsp;-&gt;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;将递增过程中的iters的每个取值转换为string<br>
<br>
Method&nbsp;1.1<br>
&nbsp;&nbsp;&nbsp;&nbsp;https://discuss.leetcode.com/topic/507/i-use-deep-first-search-dfs-idea-is-there-any-better-solutions/17<br>
&nbsp;&nbsp;&nbsp;&nbsp;搜索<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;an&nbsp;another&nbsp;solution&nbsp;that&nbsp;may&nbsp;inspire,&nbsp;with&nbsp;no&nbsp;recursion<br>
&nbsp;&nbsp;&nbsp;&nbsp;用数字&nbsp;[0..prod(len(s)&nbsp;for&nbsp;s&nbsp;in&nbsp;sets))&nbsp;来编码某个特定的indexes<br>
&nbsp;&nbsp;&nbsp;&nbsp;然后将数字转换为indexes<br>
&nbsp;&nbsp;&nbsp;&nbsp;其实就是将数字表示为各位基数不同的一种数字<br>
&nbsp;&nbsp;&nbsp;&nbsp;比如&nbsp;239&nbsp;对应的集合是&nbsp;'abc',&nbsp;'def',&nbsp;'wxyz'<br>
&nbsp;&nbsp;&nbsp;&nbsp;bases&nbsp;就是&nbsp;3,&nbsp;3,&nbsp;4<br>
&nbsp;&nbsp;&nbsp;&nbsp;结果总共有&nbsp;3&nbsp;*&nbsp;3&nbsp;*&nbsp;4&nbsp;==&nbsp;36&nbsp;个<br>
&nbsp;&nbsp;&nbsp;&nbsp;把&nbsp;[0..35]&nbsp;每个数转换为这种奇怪的&nbsp;(3,3,4)&nbsp;进制的数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;-&gt;&nbsp;0&nbsp;0&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-&gt;&nbsp;0&nbsp;0&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-&gt;&nbsp;0&nbsp;0&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;-&gt;&nbsp;0&nbsp;0&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;-&gt;&nbsp;0&nbsp;1&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;-&gt;&nbsp;0&nbsp;1&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;-&gt;&nbsp;2&nbsp;2&nbsp;3<br>
<br>
Method&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;也是上面那个链接里的，递归<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cvt(digit)&nbsp;==&nbsp;set(digits[0])&nbsp;*&nbsp;cvt(digits[1:])<br>
<br>
Method&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;构造型的<br>
&nbsp;&nbsp;&nbsp;&nbsp;同上，搜索<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;think&nbsp;I&nbsp;got&nbsp;a&nbsp;brief&nbsp;solution,&nbsp;it&nbsp;is&nbsp;not&nbsp;recursive.<br>
&nbsp;&nbsp;&nbsp;&nbsp;先第一个digit的集合，然后拿第二个digit的集合，把第一个集合里每个元素prepend到这个集合的每个元素前面<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;但是这个的缺点是，添加新的set需要对result的遍历越来越耗时<br>
&nbsp;&nbsp;&nbsp;&nbsp;比如sets的大小是&nbsp;3&nbsp;3&nbsp;4&nbsp;5<br>
&nbsp;&nbsp;&nbsp;&nbsp;第一次遍历1个元素<br>
&nbsp;&nbsp;&nbsp;&nbsp;第二次&nbsp;&nbsp;&nbsp;&nbsp;3个<br>
&nbsp;&nbsp;&nbsp;&nbsp;第三次&nbsp;&nbsp;&nbsp;&nbsp;9个<br>
&nbsp;&nbsp;&nbsp;&nbsp;第四次&nbsp;&nbsp;&nbsp;36个<br>

</p>
</body>
</html>