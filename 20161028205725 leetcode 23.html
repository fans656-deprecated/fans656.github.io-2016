<html>
<head>
<link rel="stylesheet" href="css/posts.css" />
</head>
<body>
<h1><a href="index.html">&lt;- fans656's blog</a></h1>
<p>
<span class="date">2016-10-28&nbsp;20:57:32</span><br>
Method&nbsp;1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;自己的办法<br>
&nbsp;&nbsp;&nbsp;&nbsp;先直接做k-way&nbsp;merge，每次遍历各个节点的首元素找出最大值，会在有极多list每个长度只是1的时候TLE<br>
&nbsp;&nbsp;&nbsp;&nbsp;改成两两合并，偶尔多出来的一个直接添到后面，过了<br>
&nbsp;&nbsp;&nbsp;&nbsp;看到discuss里大多是用heap，我试试<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;O(nlgk)<br>
<br>
Method&nbsp;1.1<br>
&nbsp;&nbsp;&nbsp;&nbsp;用递归实现二路合并<br>
<br>
Method&nbsp;2.<br>
&nbsp;&nbsp;&nbsp;&nbsp;小根堆，所有链表中的数都加入，然后一个个pop出来，就是有序的了<br>
&nbsp;&nbsp;&nbsp;&nbsp;要注意的是，如果想复用原有的节点(ListNode)，那么需要把tail.next置空<br>
&nbsp;&nbsp;&nbsp;&nbsp;因为heap的pop是unstable的，最终得到的最后一个节点可能next不为空<br>
&nbsp;&nbsp;&nbsp;&nbsp;这就可能造成循环链表，表现在OJ里就是它拿到linked&nbsp;list构造list的时候内存超限<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;O(nlgn)<br>
<br>
Method&nbsp;2.1<br>
&nbsp;&nbsp;&nbsp;&nbsp;小根堆，但是维护的是当前链表群的首元素<br>
&nbsp;&nbsp;&nbsp;&nbsp;O(nlgk)&nbsp;-&nbsp;k是链表个数<br>

</p>
</body>
</html>