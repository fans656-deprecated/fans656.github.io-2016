2016-10-27 09:47:57
[leetcode
    421
    maximum xor of two numbers in an array
]
Method 1.
    https://discuss.leetcode.com/topic/63299/python-6-lines-bit-by-bit
    由高位至低位enthusiastic地构造结果，尽量使高位为1
    第一次看nums中所有数的最高一位
    第二次看nums中所有书的最高两位
    第三次................最高三位
    
    如果这些数中有两个可以异或得到使当前考虑的结果中的位为1，且不与之前设置的那些位冲突的结果，那么就可以将结果当前考虑的位设置为1
    为了避免O(n^2)寻找这两个满足要求的数，我们构造一个集合，然后假设结果当前位已经设置成1，然后看这样的结果与集合中每个数异或的所得是否仍在集合中
    即看a^b==c是否在集合中，如果在，那么b^c==a就是满足要求的两个数
    
    另外，answer ^ 1 == answer | 1

Method 2.1 trie (fans656)

    将所有数加入一个trie中，然后如Method 1，从左至右构造结果
    想要设置结果当前位为1时，就看置为1的结果与数组中每个数异或所得是否仍在数组中(即这个prefix是否在trie中)
    prefix的长度从1到32，时间复杂度O(n) + O(2n) + ... + O(32n) == O(n)

Method 2.2 trie (tyn)

    仍是所有数加入trie，然后对每一个数，尝试找出数组中跟它异或所能得的最大值
    最后，所有这些最大值中最大的那个就是结果
    找的方法是，从左至右遍历这个数的位，trie从根节点起始
    如果为0，就尝试在trie中找1（反之亦然），如果找不到，就退而求其次跟随trie中有的节点
    这样的结果就是找到了跟这个数能异或得出的最大值

Method 2.3 trie incremental
    https://discuss.leetcode.com/topic/64753/31ms-o-n-java-solution-using-trie
    不必把所有数都添进去之后才开始查找，可以每添一个的同时就找
    因为异或操作是满足交换律的，这样对于每个数，都在它之前的数中找了能异或出的最大值，这样最终也能遍历到结果
